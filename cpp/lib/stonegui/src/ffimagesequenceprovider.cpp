
/*
 *
 * Copyright 2003 Blur Studio Inc.
 *
 * This file is part of libstone.
 *
 * libstone is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * libstone is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with libstone; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

/*
 * $Id: ffimagesequenceprovider.cpp 5411 2007-12-18 01:03:08Z brobison $
 */

#ifdef USE_FFMPEG

#define __STDC_CONSTANT_MACROS

#include "ffimagesequenceprovider.h"

extern "C" {
#include "avformat.h"
#include "avcodec.h"
}

#include "blurqt.h"

class FFImageSequenceProvider::Private
{
public:
	Private( FFImageSequenceProvider * provider );
	~Private();

	bool open( const QString & fileName );
	bool seek( int frameNumber );
	AVFrame * readNextFrame();
	AVFrame * convertToRGB( AVFrame * frame );
	QImage convertToQImage( AVFrame * frame );

	QImage readImage( int frameNumber );

	int64_t frameNumberToTimestamp( int frameNumber );

	int mFrameStart, mFrameEnd;
	double mFrameDuration;
	
	FFImageSequenceProvider * mProvider;
	AVFormatContext * mFormatContext;
	AVCodecContext * mCodecContext;
	AVCodec * mCodec;
	int mStreamIndex;
	AVStream * mStream;
	bool mIsOpen;
	AVPacket * mPacket;
	int mPacketDataPos;
	int mLastFrameRead;
	QImage mLastImage;
};

FFImageSequenceProvider::Private::Private( FFImageSequenceProvider * provider )
: mProvider( provider )
, mFormatContext( 0 )
, mCodecContext( 0 )
, mCodec( 0 )
, mStreamIndex( -1 )
, mStream( 0 )
, mIsOpen( false )
, mPacket( 0 )
, mPacketDataPos( 0 )
, mLastFrameRead( -1 )
{}

FFImageSequenceProvider::Private::~Private()
{
	if( mCodecContext ) {
		avcodec_close( mCodecContext );
		mCodecContext = 0;
	}
	if( mFormatContext ) {
		av_close_input_file( mFormatContext );
		mFormatContext = 0;
	}
}

bool FFImageSequenceProvider::Private::open( const QString & fileName )
{
	QByteArray fileNameLatin1 = fileName.toLatin1();
	if( av_open_input_file( &mFormatContext, fileNameLatin1.constData(), NULL, 0, NULL ) ) {
		LOG_1( "av_open_input_file failed to open file: " + fileName );
		return false;
	}

	if( av_find_stream_info( mFormatContext ) < 0 ) {
		LOG_1( "av_find_stream_info failed to find stream info for file: " + fileName );
		return false;
	}

	dump_format( mFormatContext, 0, fileNameLatin1.constData(), false );

	QList<int> videoStreams;
	for( int i = 0; i < mFormatContext->nb_streams; i++ ) {
		if( mFormatContext->streams[i]->codec->codec_type == CODEC_TYPE_VIDEO )
			videoStreams += i;
	}

	// Take the first video stream for now
	if( videoStreams.isEmpty() ) {
		LOG_1( "No video streams found in file: " + fileName );
		return false;
	}
	
	mStreamIndex = videoStreams[0];
	mStream = mFormatContext->streams[mStreamIndex];
	mCodecContext = mStream->codec;

	mCodec = avcodec_find_decoder( mCodecContext->codec_id );

	if( !mCodec ) {
		LOG_5( "Unable to find decoder for stream" );
		return false;
	}
	
	// Inform the codec that we can handle truncated bitstreams -- i.e.,
	// bitstreams where frame boundaries can fall in the middle of packets
	if( mCodec->capabilities & CODEC_CAP_TRUNCATED )
		mCodecContext->flags |= CODEC_FLAG_TRUNCATED;
	
	// Open codec
	if( avcodec_open(mCodecContext, mCodec) < 0 ) {
		LOG_5( "Unable to open codec" );
		return false;
	}

	// Hack to correct wrong frame rates that seem to be generated by some 
	// codecs
	if( mStream->r_frame_rate.num > 1000 && mStream->r_frame_rate.den == 1 )
		mStream->r_frame_rate.den=1000;

	mFrameDuration = 1000.0 * mStream->r_frame_rate.den / mStream->r_frame_rate.num;
	LOG_5( "Frame Duration: " + QString::number( mFrameDuration ) + "ms" );

	mFrameStart = (mStream->start_time * mStream->time_base.num * mStream->r_frame_rate.num) / (mStream->time_base.den * mStream->r_frame_rate.den);
	mFrameEnd = ((mStream->start_time + mStream->duration) * mStream->time_base.num * mStream->r_frame_rate.num) / (mStream->time_base.den * mStream->r_frame_rate.den);
	mLastFrameRead = mFrameStart - 1;

	mIsOpen = true;
	return true;
}

int64_t FFImageSequenceProvider::Private::frameNumberToTimestamp( int frameNumber )
{
	// seconds = frameNumber / frameRate
	// timestamp = seconds / time_base
	// timestamp = (frameNumber / frameRate) / time_base
	// timestamp = frameNumber / (time_base * frameRate)
	return (frameNumber * mStream->time_base.den * mStream->r_frame_rate.den) / (mStream->time_base.num * mStream->r_frame_rate.num);
}

bool FFImageSequenceProvider::Private::seek( int frameNumber )
{
	//LOG_5( "Seeking frame " + QString::number( frameNumber ) );
	mLastFrameRead = frameNumber - 1;
	int64_t timestamp = frameNumberToTimestamp( frameNumber );
	if( mPacket ) {
		av_free_packet( mPacket );
		delete mPacket;
		mPacket = 0;
		mPacketDataPos = 0;
	}
	return av_seek_frame( mFormatContext, mStreamIndex, timestamp, AVSEEK_FLAG_ANY ) >= 0;
}

AVFrame * FFImageSequenceProvider::Private::readNextFrame()
{
	AVFrame * frame;
	frame = avcodec_alloc_frame();

	int bytesRemaining = 0;
	int bytesDecoded = 0;
	int frameFinished = 0;

	mLastFrameRead++;

	// Decode packets until we have decoded a complete frame
	while(true)
	{
		// Work on the current packet until we have decoded all of it
		while(bytesRemaining > 0)
		{
			// Decode the next chunk of data
			bytesDecoded = avcodec_decode_video( mCodecContext, frame, &frameFinished, &mPacket->data[mPacketDataPos], bytesRemaining);

			// Was there an error?
			if(bytesDecoded < 0)
			{
				fprintf(stderr, "Error while decoding frame\n");
				goto error_exit;
			}

			mPacketDataPos += bytesDecoded;
			bytesRemaining -= bytesDecoded;

			// Did we finish the current frame? Then we can return
			if(frameFinished)
				return frame;
		}

		// Read the next packet, skipping all packets that aren't for this
		// stream
		do
		{
			// Free old packet
			if( mPacket ) {
				av_free_packet( mPacket );
				delete mPacket;
				mPacket = 0;
			}

			mPacket = new AVPacket;
			mPacketDataPos = 0;

			// Read new packet
			if( av_read_packet(mFormatContext, mPacket) < 0 )
				goto error_exit;
		} while ( mPacket->stream_index != mStreamIndex );

		bytesRemaining = mPacket->size;
    }

error_exit:
	av_free( frame );
	return 0;
}

AVFrame * FFImageSequenceProvider::Private::convertToRGB( AVFrame * frame )
{
	AVFrame * frameRGB;
	
	// Allocate an AVFrame structure
	frameRGB = avcodec_alloc_frame();
	if( !frameRGB ) {
		LOG_1( "Unable to allocate frameRGB" );
		return 0;
	}
	
	avpicture_alloc( (AVPicture*)frameRGB, PIX_FMT_RGB32, mCodecContext->width, mCodecContext->height );
	
	img_convert( (AVPicture *)frameRGB, PIX_FMT_RGB32, (AVPicture*)frame, mCodecContext->pix_fmt, mCodecContext->width, mCodecContext->height);

	return frameRGB;
}

QImage FFImageSequenceProvider::Private::convertToQImage( AVFrame * frame )
{
	bool freeFrame = false;
	if( mCodecContext->pix_fmt != PIX_FMT_RGB32 ) {
		freeFrame = true;
		frame = convertToRGB( frame );
	}

	QImage img( mCodecContext->width, mCodecContext->height, QImage::Format_RGB32 );

	memcpy( img.bits(), frame->data[0], img.width() * img.height() * 4 );

	for( int i = 0; i < img.width() * img.height(); i++ ) {
		QRgb c =  img.pixel( i % img.width(), i / img.width() );
		if( qRed(c) + qGreen(c) + qBlue(c) > 0 ) {
			//LOG_5( "Image not all black" );
			break;
		}
	}

	if( freeFrame ) {
		avpicture_free( (AVPicture*)frame );
		av_free( frame );
	}

	return img;
}

QImage FFImageSequenceProvider::Private::readImage( int frameNumber )
{
	if( mLastFrameRead != frameNumber - 1 ) {

		// Return the cached image
		if( mLastFrameRead == frameNumber && !mLastImage.isNull() )
			return mLastImage;

		if( !seek( frameNumber ) ) {
			LOG_5( "Seek failed for frame: " + QString::number( frameNumber ) );
			return QImage();
		}
	}

	AVFrame * frame = readNextFrame();
	if( !frame ) return QImage();
	QImage img = convertToQImage( frame );
	mLastImage = img;
	av_free( frame );
	return img;
}


FFImageSequenceProvider::FFImageSequenceProvider( const QString & path, QObject * parent )
: ImageSequenceProvider( parent )
, d( new Private( this ) )
, mFilePath( path )
{
	d->open( path );
}

FFImageSequenceProvider::~FFImageSequenceProvider()
{
	delete d;
}

bool FFImageSequenceProvider::isOpen()
{
	return d->mIsOpen;
}

QString FFImageSequenceProvider::path()
{
	return mFilePath;
}

int FFImageSequenceProvider::frameStart()
{
	return d->mFrameStart;
}

int FFImageSequenceProvider::frameEnd()
{
	return d->mFrameEnd;
}

ImageSequenceProvider::ImageStatus FFImageSequenceProvider::status( int )
{
	// Assume all images in a video are available
	return ImageAvailable;
}

QImage FFImageSequenceProvider::image( int frameNumber )
{
	return d->readImage( frameNumber );
}


FFImageSequenceProviderPlugin::FFImageSequenceProviderPlugin()
{
	av_register_all();
}

FFImageSequenceProviderPlugin::~FFImageSequenceProviderPlugin(){}

QStringList FFImageSequenceProviderPlugin::fileExtensions()
{
	QStringList ret;
	AVInputFormat * format = first_iformat;
	for( ; format; format = format->next ) {
		//fprintf( stderr, "avformat AVInputFormat: Name: %s Long Name %s Extensions %s\n", format->name, format->long_name, format->extensions );
		if( format->extensions )
			ret += QString::fromLatin1( format->extensions ).split(',');
//		ret += QString::fromLatin1( 
	}
	ret << "mpg" << "mpeg" << "avi";
	ret.sort();
	LOG_5( "Supported Extensions: " + ret.join(",") );
	return ret;
}

// Could use a timer to delete this if it's not used
static FFImageSequenceProvider * nextProvider = 0;

bool FFImageSequenceProviderPlugin::supportsFormat( const QString & fileName )
{
	if( nextProvider ) delete nextProvider;
	nextProvider = new FFImageSequenceProvider( fileName );
	return nextProvider->isOpen();
}

ImageSequenceProvider * FFImageSequenceProviderPlugin::createProvider( const QString & fileName )
{
	if( nextProvider && nextProvider->path() == fileName ) {
		ImageSequenceProvider * ret = nextProvider;
		nextProvider = 0;
		return ret;
	}
	return new FFImageSequenceProvider( fileName );
}

#endif // USE_FFMPEG

void registerFFImageSequenceProviderPlugin()
{
#ifdef USE_FFMPEG
	FFImageSequenceProviderPlugin * plugin = new FFImageSequenceProviderPlugin();
	plugin->fileExtensions();
	ImageSequenceProviderFactory::registerPlugin( plugin );
#endif // USE_FFMPEG
}

